import os

import cv2
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from PIL import Image
from pyfinance.ols import PandasRollingOLS

from main import read_experiment_data


class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """

    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__find_blobs_min_area = 1.0
        self.__find_blobs_circularity = [0.0, 1.0]
        self.__find_blobs_dark_blobs = False

        self.find_blobs_output = None

    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step Find_Blobs0:
        self.__find_blobs_input = source0
        (self.find_blobs_output) = self.__find_blobs(self.__find_blobs_input, self.__find_blobs_min_area,
                                                     self.__find_blobs_circularity, self.__find_blobs_dark_blobs)

    @staticmethod
    def __find_blobs(input, min_area, circularity, dark_blobs):
        """Detects groups of pixels in an image.
        Args:
            input: A numpy.ndarray.
            min_area: The minimum blob size to be found.
            circularity: The min and max circularity as a list of two numbers.
            dark_blobs: A boolean. If true looks for black. Otherwise it looks for white.
        Returns:
            A list of KeyPoint.
        """
        params = cv2.SimpleBlobDetector_Params()
        params.filterByColor = 1
        params.blobColor = (0 if dark_blobs else 255)
        params.minThreshold = 10
        params.maxThreshold = 220
        params.filterByArea = True
        params.minArea = min_area
        params.filterByCircularity = True
        params.minCircularity = circularity[0]
        params.maxCircularity = circularity[1]
        params.filterByConvexity = False
        params.filterByInertia = False
        detector = cv2.SimpleBlobDetector_create(params)
        return detector.detect(input)


def red_black_img_to_binary(img):
    return img[:, :, 0] < 255


def get_num_bubble_pixels_in_picture(img_path, debug=False):
    image = Image.open(img_path)

    if debug:
        fig, axs = plt.subplots(ncols=3, sharex=True, sharey=True)
        axs[0].imshow(~np.asarray(image), cmap='Greys')
        axs[0].set_title('Original image')

    # get blobs from the main pipeline
    pipeline = GripPipeline()
    pipeline.process(np.asarray(image))
    img_blobs_keypoints = pipeline.find_blobs_output
    blobs_only_img = cv2.drawKeypoints(np.zeros_like(image), img_blobs_keypoints, np.array([]), (0, 0, 255),
                                       cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)

    if debug:
        axs[1].imshow(cv2.cvtColor(blobs_only_img, cv2.COLOR_BGR2RGB))
        axs[1].set_title('Blobs only, unfilled')

    # fill in the blobs and get the area of the bubbles
    filled_image = cv2.floodFill(blobs_only_img, None, (0, 0), 255)[1]

    if debug:
        axs[2].imshow(red_black_img_to_binary(filled_image), cmap='Greys')
        axs[2].set_title('Blobs only, filled')

    return red_black_img_to_binary(filled_image).sum()


def analyze_all_images_in_dir(dir_path, time_between_pics=30):
    num_bubbles_pixels = []
    time = []

    current_pic_time = 0
    for img_name in os.listdir(dir_path):
        print(f'Analyzing {img_name}')

        num_bubbles_pixels.append(get_num_bubble_pixels_in_picture(dir_path + img_name))
        time.append(current_pic_time)

        current_pic_time += time_between_pics

    img_data = pd.DataFrame({'num_bubble_pixels': num_bubbles_pixels, 'time': time})
    return img_data


if __name__ == '__main__':
    dir_path = 'D:\\Users\\yonat\\Desktop\\HUJI\\HUJI Homework\\Advanced Physics Lab A\\Water Heating - Experiment B\\Camera Pics\\8.6.2020\\main exp pics\\'
    results_path = 'D:\\Users\\yonat\\Desktop\\HUJI\\HUJI Homework\\Advanced Physics Lab A\\Water Heating - Experiment B\\Results\\8.6.2020\\bubble_pixels_ex1.csv'
    experiment_path = 'D:\\Users\\yonat\\Desktop\\HUJI\\HUJI Homework\\Advanced Physics Lab A\\Water Heating - Experiment B\\Results\\8.6.2020\\main_run_data.csv'

    exp_data = read_experiment_data(experiment_path, cooling_measurement=True)
    # bubbles_data = analyze_all_images_in_dir(dir_path)
    bubbles_data = pd.read_csv(results_path)

    window_size = 20
    exp_data['temp_change_rate'] = PandasRollingOLS(x=exp_data.time, y=exp_data.temp, window=window_size).beta \
        .shift(-int(window_size / 2))

    fig, axs = plt.subplots(2, sharex=True)
    exp_data.plot(x='time', y='temp_change_rate', linestyle='None', marker='.', grid=True, ax=axs[0],
                  label='Temperature rate of change', c='k')
    # exp_data.plot(x='time', y='temp', linestyle='None', marker='.', grid=True, ax=ax)

    scale_const = 2e-7
    secondary_axis = axs[0].secondary_yaxis('right', functions=(lambda x: x / scale_const, lambda x: x * scale_const))

    bubbles_data.time += 490
    axs[0].scatter(bubbles_data.time, bubbles_data.num_bubble_pixels * scale_const, facecolors='None', edgecolors='c',
                   zorder=12, label='# of bubble pixels')

    axs[0].set_ylabel('Temperature rate of change [$\degree$C/s]')
    secondary_axis.set_ylabel('# of bubble pixels')
    axs[0].legend()

    exp_data.plot(x='time', y='temp', linestyle='None', marker='.', ax=axs[1], grid=True)

    axs[1].set_ylabel('Temperature [$\degree$C]')
    axs[1].get_legend().remove()

    plt.xlabel('Time[s]')
    axs[0].set_title('Temperature rate of change, # of bubble pixels, and temperature over time')
    plt.tight_layout()
    plt.subplots_adjust(hspace=0)
    plt.show()
