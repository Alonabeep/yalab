import os

import cv2
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from PIL import Image


class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """

    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__find_blobs_min_area = 1.0
        self.__find_blobs_circularity = [0.0, 1.0]
        self.__find_blobs_dark_blobs = False

        self.find_blobs_output = None

    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step Find_Blobs0:
        self.__find_blobs_input = source0
        (self.find_blobs_output) = self.__find_blobs(self.__find_blobs_input, self.__find_blobs_min_area,
                                                     self.__find_blobs_circularity, self.__find_blobs_dark_blobs)

    @staticmethod
    def __find_blobs(input, min_area, circularity, dark_blobs):
        """Detects groups of pixels in an image.
        Args:
            input: A numpy.ndarray.
            min_area: The minimum blob size to be found.
            circularity: The min and max circularity as a list of two numbers.
            dark_blobs: A boolean. If true looks for black. Otherwise it looks for white.
        Returns:
            A list of KeyPoint.
        """
        params = cv2.SimpleBlobDetector_Params()
        params.filterByColor = 1
        params.blobColor = (0 if dark_blobs else 255)
        params.minThreshold = 10
        params.maxThreshold = 220
        params.filterByArea = True
        params.minArea = min_area
        params.filterByCircularity = True
        params.minCircularity = circularity[0]
        params.maxCircularity = circularity[1]
        params.filterByConvexity = False
        params.filterByInertia = False
        detector = cv2.SimpleBlobDetector_create(params)
        return detector.detect(input)


def red_black_img_to_binary(img):
    return img[:, :, 0] < 255


def get_num_bubble_pixels_in_picture(img_path, debug=False):
    image = Image.open(img_path)

    if debug:
        fig, axs = plt.subplots(ncols=3, sharex=True, sharey=True)
        axs[0].imshow(~np.asarray(image), cmap='Greys')
        axs[0].set_title('Original image')

    # get blobs from the main pipeline
    pipeline = GripPipeline()
    pipeline.process(np.asarray(image))
    img_blobs_keypoints = pipeline.find_blobs_output
    blobs_only_img = cv2.drawKeypoints(np.zeros_like(image), img_blobs_keypoints, np.array([]), (0, 0, 255),
                                       cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)

    if debug:
        axs[1].imshow(cv2.cvtColor(blobs_only_img, cv2.COLOR_BGR2RGB))
        axs[1].set_title('Blobs only, unfilled')

    # fill in the blobs and get the area of the bubbles
    filled_image = cv2.floodFill(blobs_only_img, None, (0, 0), 255)[1]

    if debug:
        axs[2].imshow(red_black_img_to_binary(filled_image), cmap='Greys')
        axs[2].set_title('Blobs only, filled')

    return red_black_img_to_binary(filled_image).sum()


def analyze_all_images_in_dir(dir_path, time_between_pics=30):
    num_bubbles_pixels = []
    time = []

    current_pic_time = 0
    for img_name in os.listdir(dir_path):
        print(f'Analyzing {img_name}')

        num_bubbles_pixels.append(get_num_bubble_pixels_in_picture(dir_path + img_name))
        time.append(current_pic_time)

        current_pic_time += time_between_pics

    img_data = pd.DataFrame({'num_bubble_pixels': num_bubbles_pixels, 'time': time})
    return img_data


if __name__ == '__main__':
    dir_path = 'D:\\Users\\yonat\\Desktop\\HUJI\\HUJI Homework\\Advanced Physics Lab A\\Water Heating - Experiment B\\Camera Pics\\8.6.2020\\main exp pics\\'

    results_path = 'D:\\Users\\yonat\\Desktop\\HUJI\\HUJI Homework\\Advanced Physics Lab A\\Water Heating - Experiment B\\Results\\8.6.2020\\bubble_pixels_ex1.csv'
    analyze_all_images_in_dir(dir_path).to_csv(results_path)

    plt.show()
